// $Id: EntryMapper.java,v 1.2 2009/11/23 13:59:42 rodche Exp $
//------------------------------------------------------------------------------
/** Copyright (c) 2009 Memorial Sloan-Kettering Cancer Center.
 **
 ** This library is free software; you can redistribute it and/or modify it
 ** under the terms of the GNU Lesser General Public License as published
 ** by the Free Software Foundation; either version 2.1 of the License, or
 ** any later version.
 **
 ** This library is distributed in the hope that it will be useful, but
 ** WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
 ** MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
 ** documentation provided hereunder is on an "as is" basis, and
 ** Memorial Sloan-Kettering Cancer Center
 ** has no obligations to provide maintenance, support,
 ** updates, enhancements or modifications.  In no event shall
 ** Memorial Sloan-Kettering Cancer Center
 ** be liable to any party for direct, indirect, special,
 ** incidental or consequential damages, including lost profits, arising
 ** out of the use of this software and its documentation, even if
 ** Memorial Sloan-Kettering Cancer Center
 ** has been advised of the possibility of such damage.  See
 ** the GNU Lesser General Public License for more details.
 **
 ** You should have received a copy of the GNU Lesser General Public License
 ** along with this library; if not, write to the Free Software Foundation,
 ** Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
 **/
package org.mskcc.psibiopax.converter;

// imports
import org.biopax.paxtools.model.BioPAXElement;
import generated.psimil2.*; // this is to be auto-generated by the maven jaxb2 plugin and put in the target/generated-sources dir (default).

import java.util.Set;
import java.util.Map;
import java.util.List;
import java.util.Random;
import java.util.HashMap;
import java.util.HashSet;
import java.util.ArrayList;

/**
 * A thread class which processes an entry in a psi xml doc.
 * This class returns a paxtools model to a BioPAXMarshaller,
 * whose ref is passed during object construction.
 *
 * @author Benjamin Gross
 */
public class EntryMapper extends Thread {

	/**
	 * rdf id prefix.
	 */
	public static final String RDF_ID_PREFIX = "HTTP://PATHWAYCOMMONS.ORG/PSI2BP#";

	/**
	 * Genetic Interactions.
	 */
	private static final ArrayList<String> GENETIC_INTERACTIONS;
	static {
		GENETIC_INTERACTIONS = new ArrayList<String>();
		GENETIC_INTERACTIONS.add("dosage growth defect");
		GENETIC_INTERACTIONS.add("dosage lethality");
		GENETIC_INTERACTIONS.add("dosage rescue");
		GENETIC_INTERACTIONS.add("phenotypic enhancement");
		GENETIC_INTERACTIONS.add("phenotypic suppression");
		GENETIC_INTERACTIONS.add("synthetic growth defect");
		GENETIC_INTERACTIONS.add("synthetic haploinsufficiency");
		GENETIC_INTERACTIONS.add("synthetic lethality");
		GENETIC_INTERACTIONS.add("synthetic rescue");
	}

	/**
	 * Ref to random number generator
	 */
	private Random random;

	/**
	 * Ref to BioPAXMapper.
	 */
	private BioPAXMapper bpMapper;

	/**
	 * Ref to PSI entry.
	 */
	private EntrySet.Entry entry;

	/**
	 * Ref to marshaller.
	 */
	private BioPAXMarshaller biopaxMarshaller;

	/**
	 * Ref to interatorElementTypeMap
	 * (key is the interactor id, and the value is the InteractorElementType)
	 */
	private Map<String, InteractorElementType> interactorElementTypeMap;

	/**
	 * Ref to experimentTypeMap
	 * (key is the experiment description id, and the value is the ExperimentType)
	 */
	private Map<Integer, ExperimentType> experimentTypeMap;

	/**
	 * Set of open/controlled vocabulary.
	 */
	Set<BioPAXElement> vocabulary;

	/**
	 * Constructor.
	 *
	 * @param bpMapper BioPAXMapper
	 * @param biopaxMarshaller BioPAXMarshaller
	 * @param entry EntrySet.Entry
	 */
	public EntryMapper(BioPAXMapper bpMapper, BioPAXMarshaller biopaxMarshaller, EntrySet.Entry entry) {
		this(bpMapper, biopaxMarshaller, entry, 0);
	}

	/**
	 * Constructor.
	 *
	 * @param bpMapper BioPAXMapper
	 * @param biopaxMarshaller BioPAXMarshaller
	 * @param entry EntrySet.Entry
	 * @param seed long
	 */
	public EntryMapper(BioPAXMapper bpMapper, BioPAXMarshaller biopaxMarshaller, EntrySet.Entry entry, long seed) {

		// set member vars
		this.entry = entry;
		this.bpMapper = bpMapper;
		this.biopaxMarshaller = biopaxMarshaller;

		// random number gen setup
		this.random = (seed > 0) ?
			new Random(seed) :
			new Random(System.currentTimeMillis());
	}

	/**
	 * Our implementation of run.
	 */
	public void run() {

		// set interactor type map
		interactorElementTypeMap = createInteractorElementTypeMap(entry);

		// create set of experiment information (evidence)
		experimentTypeMap = createExperimentTypeMap(entry);
		
		// entry unification xref - map to biopax data source
		Set<BioPAXElement> bpEntryUnificationXRef = (entry.getSource() != null) ?
			getUnificationXref(entry.getSource().getXref(), true) : null;
		if (bpEntryUnificationXRef != null && bpEntryUnificationXRef.size() > 0) {
			// create data source
			bpMapper.setModelDataSource(genRdfId(), null, bpEntryUnificationXRef);
		}

		// get entry source name to add to interactions
		String entryDataSourceName = null;
		NamesType psiEntryNames = (entry.getSource() != null) ? entry.getSource().getNames() : null;
		if (psiEntryNames != null) {
			entryDataSourceName = psiEntryNames.getFullName();
			if (entryDataSourceName == null) {
				entryDataSourceName = psiEntryNames.getShortLabel();
			}
		}

		// get availability 
		Set<String> availability = new HashSet<String>();
		List<AvailabilityType> availabilityList = (entry.getAvailabilityList() != null) ? entry.getAvailabilityList().getAvailability() : null;
		if (availabilityList != null) {
			for (AvailabilityType availabilityType : availabilityList) {
				String value = availabilityType.getValue();
				if (value != null && value.length() > 0) {
					availability.add(value);
				}
			}
		}

		// iterate through the interactions
		List<EntrySet.Entry.InteractionList.Interaction> interactionList = (entry.getInteractionList() != null) ?
			(List<EntrySet.Entry.InteractionList.Interaction>)entry.getInteractionList().getInteraction() :
			new ArrayList<EntrySet.Entry.InteractionList.Interaction>();
		// cast EntrySet.Entry.InteractionList.Interaction to InteractionElementType - ok for now
		for (InteractionElementType interactionElementType : interactionList) {

			// create the paxserve interaction
			createInteraction(entryDataSourceName,
							  availability,
							  interactionElementType);
		}
		
		// add the model to the marshaller
		biopaxMarshaller.addModel(bpMapper.getModel());
	}

	/**
	 * Given an EntrySet Entry, creates a hashmap of InteractorElementTypes, 
	 * where the key is the interactor id, and the value is the InteractorElementType.
	 *
	 * Note: This is required because we process PSI compact format,
	 *       and use the protein interactor ref/id to get the protein
	 *       interactor out of the interactor list
	 *
	 * @param entry EntrySet.Entry
	 * @return Map<String, InteractorElementType>
	 */
	private Map<String, InteractorElementType> createInteractorElementTypeMap(EntrySet.Entry entry) {

		// create our hashmap to return
		Map<String, InteractorElementType> map = new HashMap<String, InteractorElementType>();

		// get interactor list
		if (entry.getInteractorList() != null) {
			List<InteractorElementType> interactorList = 
				(List<InteractorElementType>)entry.getInteractorList().getInteractor();

			// interate through interactor list
			if (interactorList != null) {
				for (InteractorElementType interactorElementType : interactorList) {
					map.put(Integer.toString(interactorElementType.getId()), interactorElementType);
				}
			}
		}

		// outta here
		return map;
	}

	/**
	 * Given an EntrySet Entry, creates a hashmap of ExperimentTypes,
	 * where the key is the experiment description id, and the value is the ExperimentType.
	 *
	 * Note: We do this because as we interate over interactions, the interaction references
	 *       an experiment, and we can use the experiment id to reference the experiment description.
	 *
	 * @param entry EntrySet.Entry
	 * @return Map<Integer, ExperimentType>
	 */
	private Map<Integer, ExperimentType> createExperimentTypeMap(EntrySet.Entry entry) {

		// create our hashmap to return
		Map<Integer, ExperimentType> map = new HashMap<Integer, ExperimentType>();

		// get experimentList
		List<ExperimentType> experimentList = (entry.getExperimentList() != null) ?
			(List<ExperimentType>)entry.getExperimentList().getExperimentDescription() :
			new ArrayList<ExperimentType>();

		for (ExperimentType experimentType : experimentList) {
			map.put(new Integer(experimentType.getId()), experimentType);
		}

		// outta here
		return map;
	}

	/**
	 * Creates a paxtools interaction object.
	 *
	 * Note:
	 *
	 * psi.interactionElementType                 -> biopax.(physicalInteraction or MolecularInteraction)
	 * psi.interactionElementType.participantList -> biopax.physicalInteraction.participants
	 *
	 * @param entryDataSourceName String
	 * @param availability Set<String>
	 * @param interactionElementType InteractionElementType
	 */
	private void createInteraction(String entryDataSourceName,
								   Set<String> availability,
								   InteractionElementType interactionElementType) {

		// a map between ParticipantType and biopax participant - required below in getExperimentalData()
		Map<ParticipantType, BioPAXElement> participantTypeToParticipantMap =
			new HashMap<ParticipantType, BioPAXElement>();

		// experiment data - get it here, because it will help us determine if interaciton is genetic
		Set<BioPAXElement> bpEvidence = getExperimentalData(interactionElementType, participantTypeToParticipantMap);

		// don't add genetic interactions to file (at least biogrid will be affected 1/6/09)
		if (bpMapper.isGeneticInteraction(GENETIC_INTERACTIONS, bpEvidence)) return;

		// get interaction name/short name
		String name = null;
		String shortName = null;
		NamesType psiInteractionNames = (interactionElementType.getNames() != null) ? interactionElementType.getNames() : null;
		if (psiInteractionNames != null) {
			name = psiInteractionNames.getFullName();
			shortName = psiInteractionNames.getShortLabel();
		}

		// interate through the psi participants, create biopax equivalents
		Set<BioPAXElement> bpParticipants = new HashSet<BioPAXElement>();
		List<ParticipantType> psiParticipantList = (interactionElementType.getParticipantList() != null) ?
			(List<ParticipantType>)interactionElementType.getParticipantList().getParticipant() :
			new ArrayList<ParticipantType>();
		for (ParticipantType participantType : psiParticipantList) {
			// get paxtools physical entity participant and add to participant list
			BioPAXElement bpParticipant = createParticipant(participantType);
			if (bpParticipant != null) {
				bpParticipants.add(bpParticipant);
				participantTypeToParticipantMap.put(participantType, bpParticipant);
			}
		}

        // interaction publication & unification xref 
		Set<BioPAXElement> bpXrefs = new HashSet<BioPAXElement>();
		if (entry.getSource() != null && entry.getSource().getBibref() != null) {
			bpXrefs.addAll(getPublicationXref(entry.getSource().getBibref().getXref()));
		}
		bpXrefs.addAll(getUnificationXref(interactionElementType.getXref(), true));

		BioPAXElement bpInteraction = bpMapper.getInteraction(genRdfId(),
															  name, shortName,
															  availability,
															  bpParticipants,
															  bpEvidence);

		// create a datasource object for the interaction
		bpMapper.setInteractionDataSource(bpInteraction, genRdfId(), entryDataSourceName, bpXrefs);
	}

	/**
	 * Creates a paxtools participant.
	 *
	 * Note:
	 *
	 * psi.participantType -> biopax.(physicalEntityParticipant or PhysicalEntity)
	 *
	 * @param participantType ParticipantType
	 *
	 * @return BioPAXElement
	 */
	private BioPAXElement createParticipant(ParticipantType participantType) {

		// features
		Set<BioPAXElement> features = getFeatureList(participantType.getFeatureList());
	
		// get protein interactor type
		// note: we process psi compact format,
		// use the interactor ref to get the interactor out of the interactor list
		String interactorRef = "";
		InteractorElementType interactorElementType = null;
		if (participantType.getInteractorRef() != null) {
			interactorRef = participantType.getInteractorRef().toString();
			interactorElementType = interactorElementTypeMap.get(interactorRef);
		}
		else if (participantType.getInteractor() != null) {
			interactorElementType = participantType.getInteractor();
			if (interactorElementType != null) {
				interactorRef = String.valueOf(interactorElementType.getId());
			}
		}

		// houston we have a problem
		if (interactorElementType == null || interactorRef.length() == 0) {
			System.err.println("EntryMapper.createParticipant(): Error - interactorElementType or Interactor cannot be found");
			System.err.println("participantType: " + participantType.toString());
			return null;
		}

		// cellular location
		BioPAXElement cellularLocation =
			getOpenControlledVocabulary((interactorElementType.getOrganism() != null) ?
										interactorElementType.getOrganism().getCompartment() : null);

		// create the physical entity which is contained within the participant, if it does not already exist
		String physicalEntityRdfId = RDF_ID_PREFIX + "_" + interactorRef;
		BioPAXElement bpPhysicalEntity = bpMapper.getBioPAXElement(physicalEntityRdfId);
		bpPhysicalEntity = (bpPhysicalEntity == null) ?
			createPhysicalEntity(physicalEntityRdfId, interactorElementType) : bpPhysicalEntity;

		// outta here
		return bpMapper.getParticipant(genRdfId(), features, cellularLocation, bpPhysicalEntity);
	}

	/**
	 * Creates a paxtools physical entity.
	 *
	 * Note:
	 *
	 * psi.interactorElementType  -> biopax.physicalEntity
	 *
	 * @param physicalEntityRdfId String
	 * @param interactorElementType InteractorElementType
	 *
	 * @return BioPAXElement
	 */
	private BioPAXElement createPhysicalEntity(String physicalEntityRdfId,
											   InteractorElementType interactorElementType) {

		// figure out physical entity type (protein, dna, rna, small molecule)
		String physicalEntityType = null;
		CvType interactorType = interactorElementType.getInteractorType();
		if (interactorType != null) {
			NamesType interactorTypeNames = interactorType.getNames();
			if (interactorTypeNames != null) {
				physicalEntityType = interactorTypeNames.getFullName();
				if (physicalEntityType == null || physicalEntityType.length() == 0) {
					physicalEntityType = interactorTypeNames.getShortLabel();
				}
			}
		}

		// get names/synonyms
		String name = null;
		String shortName = null;
		Set<String> synonyms = new HashSet<String>();
		NamesType psiNames = interactorElementType.getNames();
		if (psiNames != null) {
			name = psiNames.getFullName();
			shortName = psiNames.getShortLabel();
			List<NamesType.Alias> aliases = psiNames.getAlias();
			for (NamesType.Alias alias : aliases) {
				String value = alias.getValue();
				if (value != null && value.length() > 0) {
					synonyms.add(value);
				}
			}
		}

		return bpMapper.getPhysicalEntity(physicalEntityType, physicalEntityRdfId,
										  name, shortName, synonyms,
										  getUnificationXref(interactorElementType.getXref(), false),
										  genRdfId(),
										  getBioSource(interactorElementType.getOrganism()),
										  interactorElementType.getSequence());
	}

	/**
	 * Creates a list of paxtools elements given a psi feature list
	 *
	 * @param psiFeatureList ParticipantType.FeatureList
	 *
	 * @return Set<BioPAXElement>
	 */
	private Set<BioPAXElement> getFeatureList(ParticipantType.FeatureList psiFeatureList) {

		// check args
		if (psiFeatureList == null || psiFeatureList.getFeature().size() == 0) return null;

		// set to return
		Set<BioPAXElement> toReturn = new HashSet<BioPAXElement>();

		// interate through psi feature list
		for (FeatureElementType psiFeatureElementType : psiFeatureList.getFeature()) {

			// feature location
			Set<BioPAXElement> sequenceLocationSet =
				getSequenceLocation(psiFeatureElementType.getFeatureRangeList().getFeatureRange());

			// feature type
			BioPAXElement bpFeatureType = null;
			if (psiFeatureElementType.getFeatureType() != null) {
				bpFeatureType = getOpenControlledVocabulary(psiFeatureElementType.getFeatureType());
            }

			// xref - use feature type xref
			XrefType psiFeatureElementTypeXref = psiFeatureElementType.getXref();
			Set<BioPAXElement> bpSequenceFeatureXref = getUnificationXref(psiFeatureElementTypeXref, false);
			if (bpSequenceFeatureXref != null && bpSequenceFeatureXref.size() > 0) {
				// lets use xref id as id for feature - to eliminate duplicate features
				String id = RDF_ID_PREFIX + "SF-" + bpMapper.getXrefID(bpSequenceFeatureXref.iterator().next());
				if (id != null && id.length() > 0) {
					BioPAXElement bpSequenceFeature = bpMapper.getBioPAXElement(id);
					if (bpSequenceFeature == null) {
						toReturn.add(bpMapper.getFeature(id, bpSequenceFeatureXref, sequenceLocationSet, bpFeatureType));
					}
					else {
						// add the xref to the sequence feature
						toReturn.add(bpMapper.getFeature(bpSequenceFeature, bpSequenceFeatureXref, sequenceLocationSet, bpFeatureType));
					}
				}
			}
			else {
				toReturn.add(bpMapper.getFeature(genRdfId(), null, sequenceLocationSet, bpFeatureType));
			}
		}

		// outta here
		return toReturn;
	}

	/**
	 * Given a psiFeatureElementType, return the proper sequenceLocation.
	 *
	 * @param locationTypeList List<BaseLocationType>
	 * @return Set<BioPAXElement>
	 */
	private Set<BioPAXElement> getSequenceLocation(List<BaseLocationType> locationTypeList) {

		// set tot return
		Set<BioPAXElement> toReturn = new HashSet<BioPAXElement>();

		// if we have a locationType, lets process
		for (BaseLocationType locationType : locationTypeList) {
			if (locationType != null) {

				// get begin & end interval
				IntervalType beginInterval = locationType.getBeginInterval();
				IntervalType endInterval = locationType.getEndInterval();
				if (beginInterval == null) continue;

				// add location  to return set
				toReturn.add(bpMapper.getSequenceLocation(genRdfId(), genRdfId(), genRdfId(),
														  beginInterval.getBegin(),
														  (endInterval != null) ? endInterval.getEnd() : null));
			}
		}

		// outta here
		return toReturn;
	}


	/**
	 * Given a psi biosource, return a paxtools biosource.
	 *
	 * @param psiBioSource BioSourceType
	 * @return BioPAXElement
	 */
	private BioPAXElement getBioSource(BioSourceType psiBioSource) {

		// check args
		if (psiBioSource == null) return null;

		// set BioPXElement rdf id and taxon xref id
		String ncbiId = Integer.toString(psiBioSource.getNcbiTaxId());
		String rdfID = RDF_ID_PREFIX + "BS-" + ncbiId;

		// outta here if element already exists in model
		BioPAXElement bpBioSource = bpMapper.getBioPAXElement(rdfID);
		if (bpBioSource != null) {
			return bpBioSource;
		}

		// taxon xref
		BioPAXElement taxonXref = bpMapper.getUnificationXref(genRdfId());
		bpMapper.setXrefDBAndID(taxonXref, "TAXONOMY", ncbiId);

		// cell type
		BioPAXElement cellType = getOpenControlledVocabulary(psiBioSource.getCellType());

		// tissue
		BioPAXElement tissue = getOpenControlledVocabulary(psiBioSource.getTissue());

		String bioSourceName = null;
		NamesType psiNames = psiBioSource.getNames();
		if (psiNames != null) {
			bioSourceName = psiNames.getFullName();
			bioSourceName = (bioSourceName == null) ? psiNames.getShortLabel() : bioSourceName;
		}

		// outta here
		return bpMapper.getBioSource(rdfID, taxonXref, cellType, tissue, bioSourceName);
	}

	/**
	 * Given a CvType, return a paxtools openControlledVocabulary.
	 * 
	 * Note: this routine is exactly the same as the one above
	 *       with the exception that we take a CvType instead of OpenCvType
	 *
	 * @param cvType CvType
	 * @return BioPAXElement
	 */
	private BioPAXElement getOpenControlledVocabulary(CvType cvType) {

		// check args
		if (cvType == null) return null;

		// create OpenCvType from given CvType and
		// call getOpenControlledVocabulary(OpenCvType)
		OpenCvType openCvType = new OpenCvType();
		openCvType.setNames(cvType.getNames());
		openCvType.setXref(cvType.getXref());

		// outta here
		return getOpenControlledVocabulary(openCvType);
		
	}

	/**
	 * Given a OpenCvType, return a paxtools openControlledVocabulary.
	 *
	 * @param cvType OpenCvType
	 * @return BioPAXElement
	 */
	private BioPAXElement getOpenControlledVocabulary(OpenCvType cvType) {

		// check args
		if (cvType == null) return null;

		// try full name first, else try short name
		String nameToSearch = null;
		NamesType psiNames = cvType.getNames();
		if (psiNames != null) {
			nameToSearch = psiNames.getFullName();
			nameToSearch = (nameToSearch == null) ? psiNames.getShortLabel() : nameToSearch;
		}
		if (nameToSearch == null) return null;

		// look for name in our vocabulary set
		BioPAXElement toReturn = bpMapper.getOpenControlledVocabulary(nameToSearch);
		if (toReturn != null) return toReturn;

		// made it here, we have to create a new open/controlled vocabulary
		Set<BioPAXElement> bpXrefs = getUnificationXref(cvType.getXref(), true);
		toReturn = bpMapper.getOpenControlledVocabulary(genRdfId(), nameToSearch, bpXrefs);

		// outta here
		return toReturn;
	}

	/**
	 * Given a psi xref, returns a paxtools xref.
	 *
	 * @param psiXREF XrefType
	 * @param forOCVORDS boolean
	 * @return Set<BioPAXElement>
	 */
	private Set<BioPAXElement> getUnificationXref(XrefType psiXREF, boolean forOCVORDS) {

		// set to return
		Set<BioPAXElement> toReturn = new HashSet<BioPAXElement>();

		// check args
		if (psiXREF == null) return toReturn;

		// create list of all references
		List<DbReferenceType> psiDBRefList = new ArrayList<DbReferenceType>();
		psiDBRefList.add(psiXREF.getPrimaryRef());
		psiDBRefList.addAll(psiXREF.getSecondaryRef());

		for (DbReferenceType psiDBRef : psiDBRefList) {

			// check for null xref
			if (psiDBRef == null) continue;

			// process ref type
			BioPAXElement bpXref = null;
			String refType = psiDBRef.getRefType();
			if (refType != null && (refType.equals("identity") || refType.equals("identical object"))) {
				String id = RDF_ID_PREFIX + "UXR-" + validateDBID(psiDBRef.getId());
				bpXref = bpMapper.getBioPAXElement(id);
				if (bpXref != null) {
					toReturn.add(bpXref);
					continue;
				}
				bpXref = bpMapper.getUnificationXref(id);
			}
			else if (!forOCVORDS) {
				String id = RDF_ID_PREFIX + "RXR-" + validateDBID(psiDBRef.getId());
				bpXref = bpMapper.getBioPAXElement(id);
				if (bpXref != null) {
					toReturn.add(bpXref);
					continue;
				}
				bpXref = (refType != null) ? 
					bpMapper.getRelationshipXref(id, refType, genRdfId()) :
					bpMapper.getRelationshipXref(id, null, null);
			}
			if (bpXref != null) {
				bpMapper.setXrefDBAndID(bpXref, psiDBRef.getDb(), psiDBRef.getId());
				toReturn.add(bpXref);
			}
		}

		// outta here
		return toReturn;
	}

	/**
	 * Given a psi xref, returns a paxtools xref.
	 *
	 * @param psiXREF XrefType
	 * @return Set<BioPAXElement>
	 */
	private Set<BioPAXElement> getPublicationXref(XrefType psiXREF) {

		// set to return
		Set<BioPAXElement> toReturn = new HashSet<BioPAXElement>();

		if (psiXREF == null) return toReturn;

		// try primary first, then secondary
		DbReferenceType psiDBRef = psiXREF.getPrimaryRef();
		//psiDBRef = (psiDBRef == null) ? psiXREF.getSecondaryRef() : psiDBRef;
		if (psiDBRef == null) return toReturn;

		// create publication ref
		String id = RDF_ID_PREFIX + "PXR-" + validateDBID(psiDBRef.getId());
		BioPAXElement bpXref = bpMapper.getBioPAXElement(id);
		// outta here if element already exists in model
		if (bpXref != null) {
			toReturn.add(bpXref);
			return toReturn;
		}
		else {
			bpXref = bpMapper.getPublicationXref(id);
		}
		bpMapper.setXrefDBAndID(bpXref, psiDBRef.getDb(), psiDBRef.getId());
		
		// outta here
		toReturn.add(bpXref);
		return toReturn;
	}

	/**
	 * Validate an xref id from a psi-mi file.
	 * Replaces: reserved html chars with '-'.
	 */
	private String validateDBID(String id) {
		return id.replaceAll("\\$|\\&|\\+|,|/|:|;|=|\\?|@| ", "-");
	}

	/**
	 * Given an interaction, return a set of paxtools evidence objects.
	 *
	 * @param interactionElementType InteractionElementType
	 * @param participantTypeToParticipantMap Map<ParticipantType, BioPAXElement>
	 * @return Set<T>
	 */
	private Set<BioPAXElement> getExperimentalData(InteractionElementType interactionElementType,
												   Map<ParticipantType, BioPAXElement> participantTypeToParticipantMap) {

		// set to return
		Set<BioPAXElement> toReturn = new HashSet<BioPAXElement>();

		// get experiment list
		List<Object> experimentList = (interactionElementType.getExperimentList() != null) ?
			interactionElementType.getExperimentList().getExperimentRefOrExperimentDescription() : new ArrayList<Object>();
		
		for (Object o : experimentList) {
			// get ref to experiment type
			ExperimentType experimentType = (o instanceof Integer) ?
				experimentTypeMap.get((Integer)o) : (ExperimentType)o;
			if (experimentType != null) {
				// create comment set - used to capture name/attributes
				Set<String> comments = new HashSet<String>();
				// name
				if (experimentType.getNames() != null) {
					NamesType psiNames = experimentType.getNames();
					String name = psiNames.getFullName();
					name = (name == null) ? psiNames.getShortLabel() : name;
					if (name != null) comments.add(name);
				}
				// bibref / xref
				Set<BioPAXElement> bpXrefs = new HashSet<BioPAXElement>();
				if (experimentType.getXref() != null) {
					bpXrefs.addAll(getUnificationXref(experimentType.getXref(), false));
				}
				if (experimentType.getBibref() != null) {
					bpXrefs.addAll(getPublicationXref((experimentType.getBibref() != null) ?
													  experimentType.getBibref().getXref() : null));
				}
				// host organism list dropped
				// interaction detection method, participant detection method, feature detection method
				Set<BioPAXElement> evidenceCodes = getEvidenceCodes(experimentType);
				// confidence list
				Set<BioPAXElement> scoresOrConfidences = new HashSet<BioPAXElement>();
				List<ConfidenceListType.Confidence> confidenceList = (experimentType.getConfidenceList() != null) ?
					experimentType.getConfidenceList().getConfidence() : new ArrayList<ConfidenceListType.Confidence>();
				for (ConfidenceListType.Confidence psiConfidence : confidenceList) {
					BioPAXElement bpScoreOrConfidence = getScoreOrConfidence(psiConfidence);
					if (bpScoreOrConfidence != null) scoresOrConfidences.add(bpScoreOrConfidence);
				}
				// attribute list
				List<AttributeListType.Attribute> attributes = (experimentType.getAttributeList() != null) ?
					experimentType.getAttributeList().getAttribute() : new ArrayList<AttributeListType.Attribute>();
				comments.addAll(getAttributesSet(attributes));
				// experimental form
				Set<BioPAXElement> experimentalForms = getExperimentalFormSet(experimentType,
																			  interactionElementType,
																			  participantTypeToParticipantMap);
				// add evidence to list we are returning
				toReturn.add(bpMapper.getEvidence(genRdfId(), bpXrefs, evidenceCodes,
												  scoresOrConfidences, comments, experimentalForms));
			}
		}

		// outta here
		return toReturn;
	}

	/**
	 * Given a psi-mi experiment type, returns a set of open
	 * controlled vocabulary objects which represent evidence code(s).
	 *
	 * @param experimentType ExperimentType
	 * @return Set<BioPAXElement>
	 */
	private Set<BioPAXElement> getEvidenceCodes(ExperimentType experimentType) {

		// set to return
		Set<BioPAXElement> toReturn = new HashSet<BioPAXElement>();

		// get experiment methods
		Set<CvType> cvTypeSet = new HashSet<CvType>(3);
		cvTypeSet.add(experimentType.getInteractionDetectionMethod());
		cvTypeSet.add(experimentType.getParticipantIdentificationMethod());
		cvTypeSet.add(experimentType.getFeatureDetectionMethod());

		// create openControlledVocabulary objects for each detection method
		for (CvType cvtype : cvTypeSet) {
			if (cvtype == null) continue;
			BioPAXElement ocv = getOpenControlledVocabulary(cvtype);
			if (ocv != null) toReturn.add(ocv);
		}

		// outta here
		return toReturn;
	}

	/**
	 * Given a psi-mi confidence object, returns a paxtools confidence object.
	 *
	 * @param psiConfidence ConfidenceListType.Confidence
	 * @return BioPAXElement
	 */
	private BioPAXElement getScoreOrConfidence(ConfidenceListType.Confidence psiConfidence) {

		// check args
		if (psiConfidence == null) return null;

		// psiConfidence.value maps to confidence.confidence-value
		String value = psiConfidence.getValue();

		// get psiConfidence unit
		OpenCvType ocv = psiConfidence.getUnit(); 

		// psiConfidence.unit.xref maps to confidence.xref
		Set<BioPAXElement> bpXrefs = new HashSet<BioPAXElement>();
		if (ocv != null && ocv.getXref() != null) {
			bpXrefs.addAll(getUnificationXref(ocv.getXref(), false));
		}

		// used to store names and attributes
		Set<String> comments = new HashSet<String>();

		// psiConfidence.unit.names maps to confidence comment
		if (ocv != null && ocv.getNames() != null) {
			NamesType psiNames = ocv.getNames();
			String unitName = psiNames.getFullName();
			unitName = (unitName == null) ? psiNames.getShortLabel() : unitName;
			if (unitName != null) comments.add(unitName);
		}

		// unit.attributelist maps to confidence.comment
		List<AttributeListType.Attribute> attributes = (ocv.getAttributeList() != null) ?
			ocv.getAttributeList().getAttribute() : new ArrayList<AttributeListType.Attribute>();
		comments.addAll(getAttributesSet(attributes));

		// outta here
		return (bpMapper.getScoreOrConfidence(genRdfId(), value, bpXrefs, comments));
	}

	/**
	 * Given a psi-mi attributes list, returns a string set, where
	 * each string is concatenation of name/value pairs.
	 *
	 * @param attributes List<AttributesListType.Attribute>
	 * @return Set<String>
	 */
	private Set<String> getAttributesSet(List<AttributeListType.Attribute> attributes) {

		// set to return
		Set<String> toReturn = new HashSet<String>();

		// iterate over the attributes
		for (AttributeListType.Attribute attribute : attributes) {
			String attributeStr = "";
			String value = attribute.getValue();
			attributeStr = (value != null) ? value : attributeStr;
			String name = attribute.getName();
			attributeStr = (name != null) ? attributeStr += " " + name : attributeStr;
			String nameAc = attribute.getNameAc();
			attributeStr = (nameAc != null) ? attributeStr += " " + nameAc : attributeStr;
			if (attributeStr.length() > 0) toReturn.add(attributeStr);
		}

		// outta here
		return toReturn;
	}

	/**
	 * Given a psi-mi interaction element type, returns a set of experimental forms.
	 *
	 * @param experimentType ExperimentType
	 * @param interactionElementType InteractionElementType
	 * @param participantTypeToParticipantMap Map<ParticipantType, BioPAXElement>
	 * @return Set<BioPAXElement>
	 */
	private Set<BioPAXElement> getExperimentalFormSet(ExperimentType experimentType,
													  InteractionElementType interactionElementType,
													  Map<ParticipantType, BioPAXElement> participantTypeToParticipantMap) {

		// set to return
		Set<BioPAXElement> toReturn = new HashSet<BioPAXElement>();
		Set<String> processedRoles = new HashSet<String>();

		// interate through the psi participants, get experimental role
		List<ParticipantType> psiParticipantList = (interactionElementType.getParticipantList() != null) ?
			(List<ParticipantType>)interactionElementType.getParticipantList().getParticipant() :
			new ArrayList<ParticipantType>();
		for (ParticipantType participantType : psiParticipantList) {
			// get participant - may be used in following loop
			BioPAXElement bpParticipant = participantTypeToParticipantMap.get(participantType);
			// get experimental role list
			ParticipantType.ExperimentalRoleList erl = participantType.getExperimentalRoleList();
			if (erl == null) continue;
			for (ParticipantType.ExperimentalRoleList.ExperimentalRole experimentalRole : erl.getExperimentalRole()) {
				// get experimental ref list &
				// determine if this participant plays a role in the experiment parameter of method
				boolean relevantExperimentalRole = false;
				ExperimentRefListType experimentalRefListType = experimentalRole.getExperimentRefList();
				// according to psi-mi spec, if no experimentalRef is given,  participant plays role in all experiments
				if (experimentalRefListType == null) {
					relevantExperimentalRole = true;
				}
				else {
					List<Integer> experimentalRefList =  experimentalRefListType.getExperimentRef();
					for (Integer experimentalRef : experimentalRefList) {
						ExperimentType thisExperimentType = experimentTypeMap.get(experimentalRef);
						if (thisExperimentType == experimentType) {
							relevantExperimentalRole = true;
							break;
						}
					}
				}
				if (relevantExperimentalRole) {
					// check that we havent already processed this role to prevent duplicate experimental forms
					NamesType role = experimentalRole.getNames();
					if (role != null) {
						String roleName = role.getFullName();
						roleName = (roleName == null) ? role.getShortLabel() : roleName;
						if (!processedRoles.contains(roleName)) {
							toReturn.add(bpMapper.getExperimentalForm(genRdfId(),
																	  getOpenControlledVocabulary(experimentalRole),
																	  bpParticipant));
							processedRoles.add(roleName);
						}
					}
				}
			}
		}

		// outta here
		return toReturn;
	}

	/**
	 * Generates an RDF id required by paxtools.
	 *
	 * @return String
	 */
	private String genRdfId() {

		// return 
		return RDF_ID_PREFIX + "_" + Long.toString(Math.abs(random.nextLong()));
	}
}
